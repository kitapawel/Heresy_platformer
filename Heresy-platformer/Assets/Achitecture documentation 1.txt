# Animation architecture
-Basic animation controller. Contains all possible movements for a given type of controller (e.g. for humans).
--Override controller for different animations (e.g. for new skills).
OR
--Override controller for different enemy types with same animation sets (e.g. different armors or weapons).
-Variable animations (e.g. changed between enemies or changed by skillups) require an "empty" default state in the basic animation controller, so they can be replaced on runtime by animations specified in CharacterStats.

# Layer architecture
Actor - player and NPC. Don't collide with each other.
ActorNonCollidable - Actors transfer to this layer temporarily while dodging, rolling, falling etc. Used to avoid: missiles, falling objects.
Thrown - collides with Actor, not with ActorNotCollidable.
Pickable - collides with: pickables, thrown.

# Graphics
-If camera view size at 32 pixels per unit, then use 768x432 canvas size for background/sky images. It is divisible by 8 and allows for some vertical camera movement.
-Parallax effect structure contains 1 container object which contains subcontainers for sky/mountains/forests etc.
--Each subcontainer has a Sprite renderer and the parallax script attached.
---Each subcontainer has 2 copies of itself as children (but w/o parallax script attached). One to the left, one to the right. These will be moved when camera is out of bounds to create infinite background.


# Character setup and architecture
Input is based on ControlInput and its inherited classes: PlayerInput gets input from player. EnemyAI takes input from AI. Both send data to CharacterController to control and animate the characters.

# Camera
Maine camera + virtual camera for tracking player
-Pixel perfect camera for URP and Pixel perfect camera addon on virtual camera
-BUG: virtual camera may lose the ability to set camera size (field of view appears which is not typical to ortographic camera) - requires adding a new virtual camera

# Special ability architecture


# Combat system architecture
Combat and damage transmission works based on several systems.
1. The ControlInput and CharacterController trigger attack animation.
2. The HitCollisionChecker object contains a trigger collider and checks which targets are available for attack.
3. During an animation the DealDamage() method is called from CombatSystem. It checks the HitCollisionChecker's list, and if targets are found, deals damage to them.
4. The DealDamage() method gathers important stats from the character and its inventory and passes it to the target's HealthSystem.
5. Target's HealthSystem takes damage values and decides how to apply damage.